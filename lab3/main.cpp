#include <iostream> 
#include <fstream>
#include <queue> 

using namespace std;

const int MAXN = 100; 

int n, m; // объ€вл€ем переменные дл€ количества вершин и рЄбер графа
bool used[MAXN]; // массив дл€ отслеживани€ использовани€ вершин
int color[MAXN]; // массив дл€ цветовых меток вершин
int graph[MAXN][MAXN]; // объ€вл€ем двумерный массив дл€ хранени€ матрицы смежности
int cnt = 0; // переменна€ дл€ подсчЄта количества компонент св€зности графа

void bfs(int v) { // функци€ дл€ поиска в ширину начина€ с вершины v
    queue<int> q; 
    q.push(v); // помещаем вершину v в очередь
    color[v] = cnt; // помечаем вершину v цветом cnt
    while (!q.empty()) { // пока очередь не пуста
        int u = q.front(); // извлекаем вершину u из очереди
        q.pop(); // удал€ем вершину u из очереди
        for (int i = 1; i <= n; i++) { // дл€ всех вершин i графа
            if (color[i] == 0 && graph[u][i] == 1) { // если вершина i ещЄ не помечена и существует ребро между u и i
                color[i] = cnt; // помечаем вершину i цветом cnt
                q.push(i); // помещаем вершину i в очередь
            }
        }
    }
}

int main() { 
    ifstream fin("graph.txt");
    ofstream fout("result.txt"); 
    fin >> n >> m; // считываем количество вершин и рЄбер графа из файла

    for (int i = 1; i <= n; i++) { 
        for (int j = 1; j <= n; j++) {
            graph[i][j] = 0;
        }
    }

    for (int i = 0; i < m; i++) { // считываем из файла ребра графа
        int u, v;
        fin >> u >> v;
        graph[u][v] = graph[v][u] = 1; // помечаем ребро в матрице смежности
    }

    for (int i = 1; i <= n; i++) { // дл€ каждой вершины графа
        if (color[i] == 0) { // если вершина ещЄ не помечена
            cnt++; // увеличиваем счЄтчик компонент св€зности на 1
            bfs(i); // запускаем поиск в ширину начина€ с вершины i
        }
    }

    fout << cnt << endl; // выводим количество компонент св€зности в итоговый файл
    for (int i = 1; i <= n; i++) { // выводим цветовые метки кажой вершины в итоговый файл
        fout << color[i] << " ";
    }
    fout << endl;

    fin.close(); 
    fout.close(); 
    return 0; 
}